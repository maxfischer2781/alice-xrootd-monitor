"""
Tools to interact with XRootD's `report` functionality
"""
from __future__ import division, absolute_import
import subprocess
import ast

from . import utils


class XRootDReportManager(object):
    """
    Collects information generated by the `all.report` directive

    :param port: port receiving reports
    :type port: int

    A manager object provides reports as dictionaries on iteration. Reports
    are buffered asynchronously of iteration. Buffering is active after a call
    to :py:meth:`~.open`, and the buffer is cleared by a call to
    :py:meth:`~.close`. The buffer is also opened when iteration starts on an
    empty buffer.

    It is suggested to use this class as a context manager: the buffer is
    opened on entry and closed on exit of the context. This ensures the
    underlying resources are not unnecessarily blocked.

    :note: Reports are not buffered for multiple readers. If more than one
           thread reads reports, each receives only a fraction of reports.
    """
    def __init__(self, port):
        self.port = port
        self._reportstreamer = None

    @property
    def streaming(self):
        return self._reportstreamer is not None

    def open(self):
        """Start collecting reports"""
        if self._reportstreamer is None:
            self._reportstreamer = subprocess.Popen(
                ['mpxstat', '-p', str(self.port), '-f', 'cgi'],
                stdout=subprocess.PIPE
            )

    def close(self):
        """Stop collecting reports"""
        if self._reportstreamer is not None:
            self._reportstreamer.terminate()
            self._reportstreamer = None

    def __iter__(self):
        self.open()
        datastream = self._reportstreamer.stdout
        for line in datastream:
            datagram = dict(item.split('=') for item in line.split('&'))
            for key in datagram:
                datagram[key] = utils.safe_eval(datagram[key])
            yield datagram

    def __enter__(self):
        # start collection on entering the context, do not delay until consumption
        self.open()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def __del__(self):
        self.close()
